# Implementation Plan: Multi-Media Support (Manga, Games, Movies)

This plan outlines how to extend your media-tracker application from anime-only tracking to support manga, games, and movies.

## User Review Required

> [!IMPORTANT]
> **Breaking Changes**: This implementation will introduce a new `media_type` field that fundamentally changes how data is stored and queried. Existing anime data will need a migration to add the media type field.

> [!WARNING]
> **API Integration**: The plan assumes using these external APIs:
> - **Manga**: Jikan API (supports manga) - same API you already use
> - **Games**: IGDB API (requires free API key from Twitch Developer Portal)
> - **Movies**: TMDB API (requires free API key)
> 
> Please confirm which APIs you prefer to use, or if you want to use different ones.

> [!IMPORTANT]
> **UI/UX Decisions Required**:
> 1. **Navigation**: Should we add a media type selector in the header/sidebar, or keep everything unified?
> 2. **Categories**: Should categories (Plan to Watch, Watching, etc.) be renamed to be media-agnostic (Plan to Read/Play/Watch, etc.) or keep separate categories per media type?
> 3. **Unified vs Separated Views**: Should all media types appear together in lists/kanban, or have separate views per type?

## Proposed Changes

### Core Data Layer

#### [MODIFY] [supabase_schema.sql](./supabase_schema.sql)

**Add media type support and create unified media tables**:
- Add a new table `media_types` to store media type definitions (Anime, Manga, Games, Movies)
- Rename `anime` table to `media_items` (or keep it and deprecate for backward compatibility)
- Add `media_type_id` foreign key to reference media types
- Create media-type-specific metadata tables for fields unique to each type
- Update indexes for efficient filtering by media type

**New schema changes**:
```sql
-- Media Types table
CREATE TABLE media_types (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL UNIQUE, -- 'Anime', 'Manga', 'Game', 'Movie'
  icon TEXT, -- Icon identifier for UI
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
);

-- Rename/Extend Anime table to Media Items
CREATE TABLE media_items (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  media_type_id BIGINT REFERENCES media_types(id) NOT NULL,
  title TEXT NOT NULL,
  cover_image TEXT,
  banner_image TEXT,
  external_id INTEGER, -- MAL ID, IGDB ID, TMDB ID, etc.
  external_api TEXT, -- 'mal', 'igdb', 'tmdb', etc.
  progress_current INTEGER DEFAULT 0 NOT NULL, -- Episodes watched, chapters read, hours played, etc.
  progress_total INTEGER DEFAULT 0 NOT NULL,
  status_id BIGINT REFERENCES categories(id),
  score INTEGER DEFAULT 0 NOT NULL,
  genres TEXT[],
  release_year INTEGER,
  trailer_url TEXT,
  notes TEXT,
  activity_dates TIMESTAMP WITH TIME ZONE[], -- Watch/read/play dates
  source_links JSONB DEFAULT '[]'::jsonb, -- Watch/read/play source links
  is_deleted BOOLEAN DEFAULT FALSE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
);

-- Anime-specific metadata
CREATE TABLE anime_metadata (
  media_item_id BIGINT REFERENCES media_items(id) PRIMARY KEY,
  studios TEXT[],
  mal_id INTEGER
);

-- Manga-specific metadata
CREATE TABLE manga_metadata (
  media_item_id BIGINT REFERENCES media_items(id) PRIMARY KEY,
  authors TEXT[],
  publishers TEXT[],
  mal_id INTEGER,
  publication_status TEXT -- 'Publishing', 'Finished', 'Hiatus'
);

-- Game-specific metadata
CREATE TABLE game_metadata (
  media_item_id BIGINT REFERENCES media_items(id) PRIMARY KEY,
  developers TEXT[],
  publishers TEXT[],
  platforms TEXT[], -- 'PC', 'PS5', 'Xbox', 'Switch', etc.
  igdb_id INTEGER,
  playtime_hours DECIMAL(10, 2)
);

-- Movie-specific metadata
CREATE TABLE movie_metadata (
  media_item_id BIGINT REFERENCES media_items(id) PRIMARY KEY,
  directors TEXT[],
  cast TEXT[],
  studios TEXT[],
  tmdb_id INTEGER,
  runtime_minutes INTEGER
);
```

**Migration strategy**:
- Create migration script to copy existing `anime` data to `media_items` with `media_type_id = 1` (Anime)
- Copy anime-specific fields (studios, mal_id) to `anime_metadata` table
- Keep original `anime` table for backward compatibility during transition period

---

#### [MODIFY] [database.service.ts](./media-tracker-ui/src/app/services/database.service.ts)

**Extend Dexie schema to support multiple media types**:
- Add new table `mediaTypes` for media type definitions
- Add new table `mediaItems` to replace/extend anime table
- Add metadata tables: `animeMetadata`, `mangaMetadata`, `gameMetadata`, `movieMetadata`
- Update version and migration logic to handle data transformation
- Keep backward compatibility by maintaining `anime` table reference

```typescript
export class AnimeTrackerDatabase extends Dexie {
  mediaTypes!: Table<MediaType, number>;
  mediaItems!: Table<MediaItem, number>;
  animeMetadata!: Table<AnimeMetadata, number>;
  mangaMetadata!: Table<MangaMetadata, number>;
  gameMetadata!: Table<GameMetadata, number>;
  movieMetadata!: Table<MovieMetadata, number>;
  
  // Legacy tables (maintain for backward compatibility)
  anime!: Table<Anime, number>;
  categories!: Table<Category, number>;
  watchSources!: Table<WatchSource, number>;
  lists!: Table<List, number>;
  folders!: Table<Folder, number>;
}
```

---

### Models

#### [NEW] [media-type.model.ts](./media-tracker-ui/src/app/models/media-type.model.ts)

**Define core media type models**:
```typescript
export enum MediaType {
  ANIME = 1,
  MANGA = 2,
  GAME = 3,
  MOVIE = 4
}

export interface MediaTypeDefinition {
  id: number;
  name: string;
  icon: string;
  createdAt: Date;
}

export interface MediaItem {
  id?: number;
  supabaseId?: number;
  mediaTypeId: number;
  title: string;
  coverImage?: string;
  bannerImage?: string;
  externalId?: number;
  externalApi?: string; // 'mal', 'igdb', 'tmdb'
  progress_current: number;
  progress_total: number;
  statusId: number;
  score: number;
  genres: string[];
  releaseYear?: number;
  trailerUrl?: string;
  notes?: string;
  activityDates?: Date[];
  sourceLinks?: MediaSourceLink[];
  createdAt: Date;
  updatedAt: Date;
  lastSyncedAt?: Date;
  isDeleted?: boolean;
}

export interface MediaSourceLink {
  sourceId: number;
  url: string;
}
```

#### [NEW] [anime-metadata.model.ts](./media-tracker-ui/src/app/models/anime-metadata.model.ts)

**Anime-specific fields**:
```typescript
export interface AnimeMetadata {
  mediaItemId: number;
  studios: string[];
  malId?: number;
}
```

#### [NEW] [manga-metadata.model.ts](./media-tracker-ui/src/app/models/manga-metadata.model.ts)

**Manga-specific fields**:
```typescript
export interface MangaMetadata {
  mediaItemId: number;
  authors: string[];
  publishers: string[];
  malId?: number;
  publicationStatus?: string; // 'Publishing', 'Finished', 'Hiatus'
}
```

#### [NEW] [game-metadata.model.ts](./media-tracker-ui/src/app/models/game-metadata.model.ts)

**Game-specific fields**:
```typescript
export interface GameMetadata {
  mediaItemId: number;
  developers: string[];
  publishers: string[];
  platforms: string[]; // 'PC', 'PlayStation 5', 'Xbox Series X', 'Nintendo Switch'
  igdbId?: number;
  playtimeHours?: number;
}
```

#### [NEW] [movie-metadata.model.ts](./media-tracker-ui/src/app/models/movie-metadata.model.ts)

**Movie-specific fields**:
```typescript
export interface MovieMetadata {
  mediaItemId: number;
  directors: string[];
  cast: string[];
  studios: string[];
  tmdbId?: number;
  runtimeMinutes?: number;
}
```

---

### Services

#### [MODIFY] [anime.service.ts](./media-tracker-ui/src/app/services/anime.service.ts)

**Refactor to MediaService or maintain as legacy**:
- **Option A**: Rename to `media.service.ts` and extend to handle all media types
- **Option B**: Keep as `anime.service.ts` and create similar services for other media types
- Add methods with media type filtering
- Update all CRUD operations to work with `MediaItem` model
- Maintain backward compatibility wrapper methods for anime

**Recommended approach**: Keep `AnimeService` for backward compatibility and create a new `MediaService` that handles all types generically.

#### [NEW] [media.service.ts](./media-tracker-ui/src/app/services/media.service.ts)

**Generic media item service**:
- `getAllMedia$(mediaTypeId?: number): Observable<MediaItem[]>` - Get all media, optionally filtered by type
- `getMediaByStatus$(statusId: number, mediaTypeId?: number): Observable<MediaItem[]>`
- `getMediaById(id: number): Promise<MediaItem | undefined>`
- `addMedia(media: Omit<MediaItem, 'id' | 'createdAt' | 'updatedAt'>): Promise<number>`
- `updateMedia(id: number, updates: Partial<MediaItem>): Promise<number>`
- `deleteMedia(id: number): Promise<void>`
- `searchMediaByTitle(query: string, mediaTypeId?: number): Promise<MediaItem[]>`
- `filterMediaList(list: MediaItem[], params: MediaFilterParams): MediaItem[]`

#### [NEW] [manga.service.ts](./media-tracker-ui/src/app/services/manga.service.ts)

**Manga-specific service extending MediaService**:
- Wrapper methods that call `MediaService` with `mediaTypeId = MediaType.MANGA`
- Manga metadata CRUD operations
- Integration with Jikan API for manga search

#### [NEW] [game.service.ts](./media-tracker-ui/src/app/services/game.service.ts)

**Game-specific service**:
- Wrapper methods for game media type
- Game metadata CRUD operations
- Integration with IGDB API

#### [NEW] [movie.service.ts](./media-tracker-ui/src/app/services/movie.service.ts)

**Movie-specific service**:
- Wrapper methods for movie media type
- Movie metadata CRUD operations
- Integration with TMDB API

---

### External API Services

#### [MODIFY] [mal.service.ts](./media-tracker-ui/src/app/services/mal.service.ts)

**Extend to support manga searches**:
- Add `searchManga(query: string, limit?: number): Observable<JikanManga[]>`
- Add `getMangaById(malId: number): Observable<JikanManga | null>`
- Add `getRandomManga(): Observable<JikanManga | null>`
- Add helper method `convertJikanToManga(jikanManga: JikanManga, statusId: number)`

#### [NEW] [igdb.service.ts](./media-tracker-ui/src/app/services/igdb.service.ts)

**IGDB API integration for games**:
- Implement authentication flow (IGDB requires Twitch OAuth)
- `searchGames(query: string, limit?: number): Observable<IGDBGame[]>`
- `getGameById(igdbId: number): Observable<IGDBGame | null>`
- `getGamesByGenre(genreIds: number[]): Observable<IGDBGame[]>`
- `convertIGDBToGame(igdbGame: IGDBGame, statusId: number)`
- Cache implementation similar to MAL service

#### [NEW] [tmdb.service.ts](./media-tracker-ui/src/app/services/tmdb.service.ts)

**TMDB API integration for movies**:
- `searchMovies(query: string, limit?: number): Observable<TMDBMovie[]>`
- `getMovieById(tmdbId: number): Observable<TMDBMovie | null>`
- `getPopularMovies(page?: number): Observable<TMDBMovie[]>`
- `getMoviesByGenre(genreId: number): Observable<TMDBMovie[]>`
- `convertTMDBToMovie(tmdbMovie: TMDBMovie, statusId: number)`
- Handle API key management

#### [NEW] [jikan-manga.model.ts](./media-tracker-ui/src/app/models/jikan-manga.model.ts)

**Jikan manga response models** (similar structure to existing `mal-anime.model.ts`).

#### [NEW] [igdb-game.model.ts](./media-tracker-ui/src/app/models/igdb-game.model.ts)

**IGDB API response models**.

#### [NEW] [tmdb-movie.model.ts](./media-tracker-ui/src/app/models/tmdb-movie.model.ts)

**TMDB API response models**.

---

### UI Components

#### [MODIFY] [header.component.ts](./media-tracker-ui/src/app/components/header/header.component.ts) / [header.component.html](./media-tracker-ui/src/app/components/header/header.component.html)

**Add media type selector**:
- Add dropdown/tabs to switch between media types (All, Anime, Manga, Games, Movies)
- Store selected media type in a shared state service
- Update navigation based on selected media type
- Update "Add Anime" button to "Add Media" with type selection

#### [NEW] [media-type-selector.component.ts](./media-tracker-ui/src/app/components/media-type-selector/media-type-selector.component.ts)

**Standalone media type selector component**:
- Display media type icons/buttons
- Emit selected media type changes
- Show active state for current selection
- Can be reused across different pages

#### [MODIFY] [add-anime-dialog](./media-tracker-ui/src/app/components/add-anime-dialog/add-anime-dialog.component.ts)

**Transform into generic "Add Media" dialog**:
- Add media type selection at the top of dialog
- Dynamically load appropriate search service based on media type
- Show media-type-specific fields conditionally
- Update form validation based on media type
- Handle metadata creation for each type

**Alternative**: Create separate dialogs for each media type and route to appropriate one based on selection.

#### [NEW] [add-manga-dialog](./media-tracker-ui/src/app/components/add-manga-dialog/add-manga-dialog.component.ts)

**Manga-specific add dialog** (if using separate dialogs approach):
- Search manga via Jikan API
- Display manga-specific fields (authors, publishers, chapters)
- Handle manga metadata

#### [NEW] [add-game-dialog](./media-tracker-ui/src/app/components/add-game-dialog/add-game-dialog.component.ts)

**Game-specific add dialog**:
- Search games via IGDB API
- Display game-specific fields (developers, publishers, platforms, playtime)
- Handle game metadata

#### [NEW] [add-movie-dialog](./media-tracker-ui/src/app/components/add-movie-dialog/add-movie-dialog.component.ts)

**Movie-specific add dialog**:
- Search movies via TMDB API
- Display movie-specific fields (directors, cast, runtime)
- Handle movie metadata

#### [MODIFY] [kanban-board](./media-tracker-ui/src/app/components/kanban-board/kanban-board.component.ts)

**Support multiple media types in Kanban view**:
- Filter media items by selected media type
- Update card rendering to show media-type-specific icons/badges
- Handle media type in drag-and-drop operations
- Option to show all media types or filter by one

#### [MODIFY] [kanban-anime-card](./media-tracker-ui/src/app/pages/home/components/kanban-anime-card/kanban-anime-card.html)

**Rename to `media-card` and extend**:
- Show media type badge/icon
- Display appropriate progress indicator based on type:
  - Anime/Manga: Episodes/Chapters
  - Games: Hours played or percentage
  - Movies: Watched/Not watched
- Show media-type-specific metadata

#### [MODIFY] [list-view](./media-tracker-ui/src/app/components/list-view/list-view.component.ts)

**Support multiple media types in list view**:
- Add media type column or filter
- Update columns based on media type
- Handle media-type-specific sorting

#### [MODIFY] [anime-details-dialog](./media-tracker-ui/src/app/components/anime-details-dialog/anime-details-dialog.component.ts)

**Transform to generic media details dialog**:
- Load media item and its type-specific metadata
- Render appropriate fields based on media type
- Show media-type-specific sections (studios for anime, platforms for games, etc.)

---

### Pages

#### [MODIFY] [home.component.ts](./media-tracker-ui/src/app/pages/home/home.component.ts)

**Update home page to handle multiple media types**:
- Subscribe to media type selection changes
- Filter displayed media based on selected type
- Update "Add" button behavior based on selected type

#### [MODIFY] [animes-details](./media-tracker-ui/src/app/pages/animes-details/animes-details.ts)

**Rename to `media-details` or support generic media**:
- Load media item based on ID and type
- Render appropriate metadata sections
- Update route to `/media/:id` or add type parameter `/media/:type/:id`

#### [MODIFY] [lists](./media-tracker-ui/src/app/pages/lists/lists.ts)

**Support multi-media lists**:
- Allow lists to contain mixed media types OR be media-type-specific
- Update list creation to optionally specify media type filter
- Show media type indicators on list items

#### [MODIFY] [stats.component.ts](./media-tracker-ui/src/app/pages/stats/stats.component.ts)

**Extend statistics for all media types**:
- Show stats per media type (total anime, total manga, total games, total movies)
- Show combined statistics
- Add media type breakdown charts
- Calculate total hours watched/read/played

#### [MODIFY] [browse.component.ts](./media-tracker-ui/src/app/pages/browse/browse.component.ts)

**Add media type filtering to browse**:
- Filter external search results by media type
- Switch API service based on media type selection

---

### Shared State & Context

#### [NEW] [media-type-state.service.ts](./media-tracker-ui/src/app/services/media-type-state.service.ts)

**Global media type selection state**:
- Store currently selected media type (or "All")
- Provide observable for components to subscribe to changes
- Persist selection to localStorage
- Methods to get/set media type filter

```typescript
@Injectable({ providedIn: 'root' })
export class MediaTypeStateService {
  private selectedMediaType$ = new BehaviorSubject<number | null>(null); // null = all types
  
  getSelectedMediaType$(): Observable<number | null> { }
  setSelectedMediaType(typeId: number | null): void { }
  getCurrentMediaType(): number | null { }
}
```

---

### Categories & Status Updates

#### [MODIFY] [status.model.ts](./media-tracker-ui/src/app/models/status.model.ts)

**Update category names to be media-agnostic**:
- **Option A**: Keep existing categories and interpret based on media type context
  - "Plan to Watch" → used as "Plan to Read" for manga, "Plan to Play" for games, etc.
- **Option B**: Create separate categories per media type
  - Anime: Plan to Watch, Watching, Completed, On Hold, Dropped
  - Manga: Plan to Read, Reading, Completed, On Hold, Dropped
  - Games: Plan to Play, Playing, Completed, On Hold, Dropped
  - Movies: Plan to Watch, Watching (maybe N/A), Completed
- **Option C**: Use truly generic categories
  - Plan to Start, In Progress, Completed, On Hold, Dropped

**Recommended**: Option A for simplicity, but add a `displayName(mediaTypeId: number)` method to categories for proper UI labels.

---

### Routes

#### [MODIFY] [app.routes.ts](./media-tracker-ui/src/app/app.routes.ts)

**Update routes to support media types**:
- Change `/anime/:id` → `/media/:id` or `/media/:type/:id`
- Keep anime routes for backward compatibility
- Add manga, game, movie specific routes if needed
- Update route parameters to pass media type context

---

### Migration Scripts

#### [NEW] [migrate-to-media-items.sql](./supabase_migration_media.sql)

**Supabase migration script**:
- Create new tables (`media_types`, `media_items`, metadata tables)
- Insert media type definitions
- Migrate existing anime data to `media_items` with `media_type_id = 1`
- Migrate anime-specific data to `anime_metadata`
- Update foreign keys in lists table
- Create indexes for performance

#### [NEW] [dexie-migration.ts](./media-tracker-ui/src/app/services/dexie-migration.ts)

**Frontend IndexedDB migration**:
- Upgrade Dexie schema version
- Migrate local anime data to `media_items` structure
- Handle offline-first scenarios
- Ensure sync compatibility

---

## Verification Plan

### Automated Tests

1. **Database Migration Tests**
   ```bash
   # Test Supabase migration
   npm run test:migration
   ```
   - Verify all anime data migrated correctly
   - Check foreign key constraints
   - Validate indexes created

2. **Service Unit Tests**
   ```bash
   npm run test:services
   ```
   - Test `MediaService` CRUD operations for each media type
   - Test API service integrations (mock responses)
   - Test filtering and search across media types

3. **Component Tests**
   ```bash
   npm run test:components
   ```
   - Test media type selector
   - Test add media dialog switching between types
   - Test card rendering for different media types

### Manual Verification

1. **Data Migration Validation**
   - Verify all existing anime appear correctly after migration
   - Check that no data was lost
   - Confirm anime-specific metadata (studios, MAL IDs) preserved

2. **Add New Media**
   - Add a new manga and verify it appears in lists/kanban
   - Add a new game with platform/developer info
   - Add a new movie with cast/director info
   - Verify each uses the correct external API

3. **Media Type Filtering**
   - Switch between media types using selector
   - Verify only relevant items display
   - Check "All" option shows everything
   - Verify filter persists across page navigation

4. **External API Integration**
   - Search for manga using Jikan API
   - Search for games using IGDB API (if API key configured)
   - Search for movies using TMDB API (if API key configured)
   - Verify cover images, metadata fetched correctly

5. **Multi-Media Lists**
   - Create a list with mixed media types
   - Verify list displays all media correctly
   - Test filtering within lists by media type

6. **Statistics & Year Recap**
   - Verify stats page shows breakdown by media type
   - Check year recap includes all media types
   - Validate totals and calculations

7. **UI/UX Review**
   - Verify media type icons/badges display correctly
   - Check responsive design for new components
   - Test dark mode compatibility
   - Verify accessibility (keyboard navigation, screen readers)

### Browser Testing

Use browser automation to test key workflows:
- Navigate to home, switch media type, add new media item
- Create a list, add multiple media types, verify display
- Open media details for each type, check all fields display

---

## Implementation Order Recommendation

1. **Phase 1: Database & Models** (Foundation)
   - Create new database schema
   - Define TypeScript models
   - Write migration scripts
   - Test migrations locally

2. **Phase 2: Core Services** (Business Logic)
   - Create `MediaService` and `MediaTypeStateService`
   - Extend existing services for backward compatibility
   - Implement API services (IGDB, TMDB)
   - Extend MAL service for manga

3. **Phase 3: UI Components** (User Interface)
   - Add media type selector
   - Update header component
   - Create/update add media dialogs
   - Update cards and lists to show media types

4. **Phase 4: Pages & Routes** (Navigation)
   - Update routing
   - Modify pages to use media type filter
   - Update stats and timeline

5. **Phase 5: Testing & Polish** (Quality)
   - Run all tests
   - Manual verification
   - UI/UX polish
   - Performance optimization

---

## Notes & Considerations

- **API Keys**: IGDB and TMDB require free API keys. You'll need to set up developer accounts and configure environment variables.
- **Rate Limiting**: Implement rate limiting for all external APIs to avoid hitting limits.
- **Caching**: Extend caching strategy to all API services to reduce external requests.
- **Offline Support**: Ensure IndexedDB (Dexie) properly handles all media types in offline scenarios.
- **Performance**: Monitor query performance with larger datasets and multiple media types. May need additional indexes.
- **Internationalization**: Consider how media titles in different languages should be handled (TMDB supports multiple languages).
- **User Preferences**: Consider allowing users to enable/disable specific media types if they only want to track some types.
